import { spawn } from 'child_process';

/**
 * Streams a PDF generated by FOP from given XML and XSL-FO template.
 *
 * @param {string} xml - The XML string to transform.
 * @param {string} xslPath - Path to the XSL-FO template.
 * @param {Object} res - Express response object.
 * @param {string} fileName - PDF filename for download.
 * @param {string} [fopPath='/usr/bin/fop'] - Optional path to FOP executable.
 */
export function streamFOP(xml, xslPath, res, fileName, outputFormat, fopPath = '/usr/bin/fop') {
  try {
    const fop = spawn(fopPath, [
      '-xml', '-',
      '-xsl', xslPath,
      `-${outputFormat}`, '-'   // use '-pdf', '-rtf', etc.
    ], { stdio: ['pipe','pipe','pipe'] });

    const timeout = setTimeout(() => fop.kill('SIGKILL'), 30000);

    fop.stdin.write(xml);
    fop.stdin.end();

    let stderr = '';
    fop.stderr.on('data', chunk => stderr += chunk.toString());

    // Adjust Content-Type based on format
    const mimeType = outputFormat === 'rtf' ? 'application/rtf' : 'application/pdf';
    res.setHeader('Content-Type', mimeType);
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    fop.stdout.pipe(res);

    fop.on('close', code => {
      clearTimeout(timeout);
      if (code !== 0) {
        console.error('FOP error:', stderr);
        if (!res.headersSent) res.status(500).send(`${outputFormat.toUpperCase()} generation failed`);
      }
    });

    fop.on('error', err => {
      clearTimeout(timeout);
      console.error('Failed to spawn FOP:', err);
      if (!res.headersSent) res.status(500).send(`Failed to start FOP process`);
    });

    res.on('close', () => {
      if (!res.writableEnded) fop.kill('SIGKILL');
    });

  } catch (err) {
    console.error(err);
    if (!res.headersSent) res.status(500).send('Server error');
  }
}