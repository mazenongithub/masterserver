import { spawn } from 'child_process';

/**
 * Streams a PDF generated by FOP from given XML and XSL-FO template.
 *
 * @param {string} xml - The XML string to transform.
 * @param {string} xslPath - Path to the XSL-FO template.
 * @param {Object} res - Express response object.
 * @param {string} fileName - PDF filename for download.
 * @param {string} [fopPath='/usr/bin/fop'] - Optional path to FOP executable.
 */
export function streamFOP(xml, xslPath, res, fileName, fopPath = '/usr/bin/fop') {
  try {
    const fop = spawn(fopPath, ['-xml', '-', '-xsl', xslPath, '-pdf', '-'], { stdio: ['pipe', 'pipe', 'pipe'] });

    // Optional timeout (30s)
    const timeout = setTimeout(() => fop.kill('SIGKILL'), 30000);

    // Send XML to FOP
    fop.stdin.write(xml);
    fop.stdin.end();

    // Capture FOP errors
    let stderr = '';
    fop.stderr.on('data', chunk => stderr += chunk.toString());

    // Stream PDF to client
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    fop.stdout.pipe(res);

    // Handle FOP exit
    fop.on('close', code => {
      clearTimeout(timeout);
      if (code !== 0) {
        console.error('FOP error:', stderr);
        if (!res.headersSent) res.status(500).send('PDF generation failed');
      }
    });

    // Handle spawn errors
    fop.on('error', err => {
      clearTimeout(timeout);
      console.error('Failed to spawn FOP:', err);
      if (!res.headersSent) res.status(500).send('Failed to start FOP process');
    });

    // Kill FOP if client disconnects
    res.on('close', () => {
      if (!res.writableEnded) fop.kill('SIGKILL');
    });

  } catch (err) {
    console.error(err);
    if (!res.headersSent) res.status(500).send('Server error');
  }
}
